# 1.2 Browser
## 1.2.1 Структурная схема
````
┌───────────────────────────────────────────────────────────────┐
│                        Веб-браузер                            │
│                                                               │
│  ┌─────────────┐    ┌─────────────┐    ┌──────────────────┐   │
│  │  Пользова-  │    │             │    │                  │   │
│  │  тельский   │◄──►│    Ядро     │◄──►│   Сетевые        │   │
│  │  интерфейс  │    │  браузера   │    │   компоненты     │   │
│  └─────────────┘    │             │    │                  │   │
│                     └─────────────┘    └──────────────────┘   │
│                            ▲                   ▲              │
│                            │                   │              │
│                     ┌──────┴──────┐    ┌───────┴───────┐      │
│                     │             │    │               │      │
│                     │  Движок     │    │  Хранение     │      │
│                     │  рендеринга │    │  данных       │      │
│                     │             │    │               │      │
│                     └──────┬──────┘    └───────┬───────┘      │
│                            │                   │              │
│                     ┌──────▼──────┐    ┌───────▼───────┐      │
│                     │             │    │               │      │
│                     │  JavaScript │    │  Безопасность │      │
│                     │  интерпре-  │    │  и проверки   │      │
│                     │  татор      │    │               │      │
│                     └─────────────┘    └───────────────┘      │
│                                                               │
└───────────────────────────────────────────────────────────────┘
````
### 1.2.1.1 Пользовательский интерфейс

Интерфейс, через который пользователь взаимодействует с браузером:
* Строка с полем ввода URL
* Кнопка перезагрузки страницы
* и т.п.

### 1.2.1.2 Ядро браузера (браузерный движок)
Ядро браузера aka браузерный движок - браузерная платформа, уже готовый браузер, поверх которого могут создаваться кастомные браузеры: удаляется лишнее, например, трекеры и добавляется что-то свое.

---

Так например есть браузерный движок `Chromium`, поверх которого построены браузеры - Google Chrome, Brave, Microsoft Edge ...

`Chromium` появился в 2008 г. и изначально opensource проект, исходники которого можно глянуть [здесь](https://chromium.googlesource.com/chromium/src)

Браузеры на движке `Chromium` занимают около 80% рынка.

---

Также существует движок `Gecko`, появился в 1998 г.

На этом движке работает Firefox, Tor и LibreWolf.

---

Основное различие в архитектуре. У `Chromium` она многопоточная, в то время как у `Gecko` гибридная (комбинация однопоточной и многопоточной). Как результат - `Gecko` в среднем меньше потребляет RAM, однако `Chromium` засчет полной многопточности является более безопасным и устойчивым к падениям.  
### 1.2.1.3 Движок рендеринга и стадии рендера
Выполняет ключевую часть работы браузера: рендеринг и ререндеринг содержимого страниц.

Список основных движков рендера:
1. `Blink` (`Chromium`)
2. `Quantum` (`Gecko`)
3. `WebKit` (в браузерах от Apple - Safari и во всех браузерах под iOS и IPadOS)

**Стадии рендера**
1. **Parsing**. Браузерные HTML и CSS-парсеры парсят сырой HTML и CSS в DOM и CSSOM.

_Примечание:_ парсинг `DOM` может приостановиться на строке с `<script>`, если у тега нет аттрибутов `async`/`defer`

_Примечание:_ `CSSOM` строится параллельно с `DOM`, но его построение блокирующее: браузер не отобразит страницу, пока не обработает все CSS, чтобы избежать "мелькания" нестилизованного контента.
2. **Precomposite** / **style**. Объединение DOM и CSSOM в одно дерево — `Render Tree`, где у каждой ноды проставлены соответствующие стили.
3. **Layout** / **reflow**. Вычисление точного положения и геометрии каждого элемента на странице. Браузер определяет, где и какого размера должен быть каждый элемент.
Подробнее:
* Процесс начинается с корневого элемента и рекурсивно проходит по всему `Render Tree`.
* Рассчитываются координаты (x, y), ширина, высота, отступы, границы.
* Это самая ресурсоемкая операция. Изменение геометрии элемента (например, ширины или высоты) через JavaScript заставляет браузер пересчитывать **Layout** (вызывать reflow) для затронутых элементов и, возможно, всей страницы.
4. **Composition** / **rasterization and painting**. Это многоступенчатая стадия, которая превращает вычисленные layout'ы в пиксели:
   1. **Paint**. Создание списка операций отрисовки (paint records или display lists). Это не рисует пиксели, а лишь записывает команды: "нарисовать текст 'Hello' шрифтом Arial 16px красного цвета в координатах (50, 100)".
   2. **Rasterization**. Превращение этих команд в реальные пиксели в bitmap. Растеризация часто происходит на GPU (графическом процессоре), что гораздо быстрее. Этот этап выполняется специальными потоками — raster threads.
   3. **Composite**. Сборка всех растрированных слоев (layers) в окончательное изображение для экрана. Слои накладываются друг на друга в правильном порядке (according to `z-index`) и отправляются на экран. Это делается отдельным compositor thread.

_Примечание:_ Ключевая идея Compositor Thread: Он может работать независимо от main thread. Если анимация меняет только свойства, влияющие на композицию (например, `transform`, `opacity`), compositor может обновить кадр, не задействуя дорогостоящие Layout и Paint. Это гарантирует плавность в 60 FPS.
### 1.2.1.4 JavaScript интерпретатор
Список основных JS-интерпретаторов:
1. `V8` (`Chromium`)
2. `SpiderMonkey` (`Gecko`)
3. `Nitro` (в браузерах от Apple - Safari и во всех браузерах под iOS и IPadOS)

### 1.2.1.5 Сетевые компоненты

В современных браузерных архитектурах вся сетевая подсистема (net/) работает в выделенном процессе — Network Service

**Network manager**

Координирует исходящие сетевые запросы. Среди выполняемых задач:
* Очередь и приоритизация: какой запрос выполнить первым (например, HTML важнее CSS, а CSS важнее изображения).
* Управление соединениями: Открывает, переиспользует и закрывает TCP-соединения в соответствии с лимитами (браузер не может открыть бесконечное число соединений на один сервер).
* Соблюдение политик: Контролирует правила CORS, Same-Origin Policy и др.

**Resource cache**
Хранит статические ресурсы (изображения, CSS, JS) локально, чтобы избежать лишних сетевых запросов.

Работает так: перед тем как сделать запрос, браузер проверяет кэш. Если там есть валидная (свежая) копия ресурса, он использует её. Управление происходит через HTTP-заголовки (`Cache-Control`, `ETag`, `Last-Modified`).

Кэшируются в основном GET-запросы. Относится к кэшу ресурсов, а не к куки или LocalStorage.

**DNS Resolver / DNS Prefetching**
Маппит доменные имена и их сетевые адреса. Например: `youtube.com`: `142.251.39.46`

Технология DNS-prefetching позволяет в фоновом режиме браузеру определять сетевые адреса ссылок на странице

**Connection manager**
Осуществляет управление соединениями по протоколам транспортного уровня (TCP, UDP, QUIC).

Ключевые аспекты:
* установка соединения
* переиспользование (`Keep-Alive`): после загрузки ресурса соединение не разрывается сразу, а сохраняется для последующих запросов к тому же серверу, экономя время на повторном handshake.
* ограничение числа соединений: обычно 6-8

**Security manager**

Обеспечение безопасного и зашифрованного соединения по HTTPS.
Ключевые аспекты:
* "Рукопожатие" (TLS Handshake): Договаривается с сервером о версии протокола и шифрах.
* Проверка сертификатов: Убеждается, что сертификат сервера выдан доверенным центром сертификации (CA), не просрочен и соответствует запрашиваемому домену.
* Шифрование/Расшифровка: Шифрует исходящие данные и расшифровывает входящие.

**Poxy & VPN manager**

Обработка настроек прокси-серверов и VPN, указанных в операционной системе или в настройках самого браузера. Все сетевые запросы перенаправляются через указанный промежуточный сервер.

**HTTP handler**
Ключевые аспекты:
* Парсинг и генерация HTTP-заголовков, соблюдение semantics протокола (коды ответа, методы, куки).
* Управление файлами куки: отправка соответствующих кук на сервер с каждым запросом и сохранение кук из заголовков Set-Cookie в ответах сервера.

**Websocket & WebRTC handler**
Работа со специализированными сетевыми протоколами, отличными от HTTP.

### 1.2.1.6 Хранение данных

**Cookies**

Механизм управления состоянием сессии и хранения небольших данных, в первую очередь для аутентификации и персонализации.

Ограничения: ~4 КБ на домен, отправляются с каждым HTTP-запросом, что может негативно сказываться на производительности.

**Web storage (LocalStorage & SessionStorage)**

Простое хранение пар «ключ-значение» на стороне клиента. Пришло на смену кукам для хранения данных, которые не нужно отправлять на сервер с каждым запросом.

LocalStorage: Данные сохраняются навсегда (или до явного удаления) и доступны для всех вкладок и окон одного origin (домена, протокола, порта).

SessionStorage: Данные живут только в течение сессии (пока открыта вкладка/окно браузера). Данные изолированы даже между вкладками с одним origin.

Ограничения: Обычно ~5-10 МБ на домен. Не отправляются на сервер автоматически. Доступ только через JavaScript на том же origin.

**IndexedDB**

Полноценная NoSQL база данных на стороне клиента для хранения больших объемов структурированных данных.

Как работает?

* Позволяет хранить не только строки, но и сложные объекты, файлы, blobs.
* Поддерживает индексы для высокопроизводительного поиска.
* Работает асинхронно (не блокирует основной поток страницы) и основана на транзакциях.

Для чего используется? Кэширование больших наборов данных (каталоги товаров, почта), оффлайн-функциональность прогрессивных веб-приложений (PWA), хранение пользовательского контента.

Ограничения: Гибкие, обычно составляет не менее 50% от свободного места на диске, но браузер может запросить у пользователя разрешение на увеличение лимита.

**Cache API**
Программное управление кэшем HTTP-ответов (скриптов, стилей, изображений, даже HTML-страниц). Ключевой компонент `Service Workers` и технологии `PWA`.

Отличие от HTTP-кэша: Управляется не заголовками, а JavaScript-кодом разработчика. Более гибкий и мощный.

Разработчик может в скрипте (`Service Worker`) перехватывать сетевые запросы и решать: отдать ресурс из кэша, отправить запрос в сеть или скомбинировать оба подхода (Cache First, Network First и др.).

### 1.2.1.7 Безопасность и проверки (компоненты безопасности)
**Sandbox**

Технология, которая изолирует процессы браузера (вкладки, расширения) от основной операционной системы и друг от друга.

* Как работает? Браузер работает на двух уровнях:
1. Брокер (Broker Process): Имеет полные права на доступ к ОС. Управляет интерфейсом, вкладками и сетью.
2. Процессы-песочницы (Renderer Processes): В них работает код веб-страниц. Эти процессы имеют крайне ограниченные права. Они не могут напрямую читать файлы на диске, получать доступ к камере или микрофону без явного разрешения пользователя, вызванного через брокер.
* Зачем нужно? 

Если вы посетите вредоносный сайт, и он найдет уязвимость в движке рендеринга, атака будет заперта внутри песочницы. Злоумышленник не сможет установить вирус, удалить файлы или получить доступ к вашим данным на диске.
* Реализация

В Chrome/Edge используется песочница на уровне ОС Windows (на базе технологии Sandbox). В Firefox и Safari также реализованы свои модели изоляции.

---

**Изоляция источников (Site Isolation)**
   
Это логическое развитие идеи песочницы и является функцией, которая гарантирует, что страницы с разных веб-сайтов всегда будут работать в разных процессах.

* Как работало раньше? 

Несколько вкладок с одного сайта (например, разные почты Gmail) могли делить один процесс.

* Зачем нужно? 

Для защиты от атак типа Spectre, которые теоретически могли позволить одному сайту прочитать данные другого сайта, загруженного в том же процессе. Теперь, даже если сайт evil.com и ваш банк bank.com открыты в одном окне, их код выполняется в абсолютно изолированных друг от друга процессах. evil.com не может "дотянуться" до данных bank.com.

---

**Механизм контроля доступа - CORS (Cross-Origin Resource Sharing)**

Правило безопасности браузера, которое по умолчанию запрещает веб-странице делать запросы к другому домену (источнику, origin), отличному от того, с которого она загружена.

---

**Политика одинакового источника (Same-Origin Policy - SOP)**

Базовый принцип, на котором построена безопасность веба. Он ограничивает возможности скриптов одной страницы взаимодействовать с ресурсами другой страницы, если у них разный "источник" (сочетание протокола, домена и порта).

---

**Защита конфиденциальности (Privacy Features)**

Современные браузеры активно внедряют функции для защиты от слежки:

* Блокировка трекеров (Tracking Protection): Браузер (особенно Firefox и Safari) автоматически блокирует скрипты и запросы от известных трекеров, которые собирают данные о вашем поведении в интернете.


* Умная блокировка кук (Intelligent Tracking Prevention - ITP в Safari): Автоматически изолирует и удаляет куки, используемые для межсайтового отслеживания.


* Защита от fingerprinting (создания цифрового отпечатка): Браузеры пытаются ограничить доступ к неочевидным параметрам системы (списку установленных шрифтов, точным характеристикам GPU и т.д.), которые используются для уникальной идентификации пользователя без его ведома.

---

**Безопасность расширений (Extension Security)**
* Магазины расширений: Chrome Web Store, Firefox Add-ons проводят модерацию и проверку расширений на вредоносный код.
* Разрешения (Permissions): Перед установкой расширение должно запросить у пользователя доступ к данным сайтов, вкладкам и т.д. Пользователь видит, к чему расширение получит доступ.
* Изоляция: Расширения часто работают в своих собственных изолированных процессах.
## 1.2.4 API
### 1.2.4.1 Event Loop
Event loop – механизм, позволяющий использовать неблокирующую модель ввода/вывода. Решает задачу распараллеливания выполнения кода: например, при отправке запроса на сервер чтобы не повисал весь UI.

Event loop не является частью JS. В `Chromium` (браузерный движок аля стоковый браузер) используется `V8` для обработки JS, в NodeJS также используется `V8`, но при этом Event Loop в браузере и в Node JS – реализованы по-разному, хотя решают одну и ту же задачу.

Микротаски - в большинстве случаев порождаются промисами, а также:
* Метод `queueMicrotask(callback)` у объекта `window`: добавляет callback в `microtask queue`
* mutationObserver - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в `microtask queue` в случае изменений.

Макротаски - это все остальное, что не синхронный код и не перечисленное выше:
* `setTimeout`, `setInterval`
* Обработчики событий в `DOM`
* Работа с файловой системой

### 1.2.4.1 DOM
